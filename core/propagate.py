"""Schema propagation utilities (CS_SCHEMA_PROPAGATE / PIPE_PROP).

These helpers introspect the RecruitingWizard schema and emit synchronised
artifacts for UI components and export helpers. They are consumed by
``scripts/propagate_schema.py`` to ensure schema changes propagate throughout the
codebase.
"""

from __future__ import annotations

import types
from dataclasses import dataclass
from difflib import unified_diff
from pathlib import Path
from typing import Any, Mapping, Sequence
from typing import Dict, FrozenSet, List, Set, Tuple, Union
from typing import get_args, get_origin

from core import schema


@dataclass(frozen=True)
class FieldDescriptor:
    """Description of a canonical RecruitingWizard field."""

    path: str
    python_type: str
    is_collection: bool


@dataclass(frozen=True)
class GeneratedFile:
    """A file generated by the propagation pipeline."""

    path: Path
    content: str


@dataclass(frozen=True)
class FileStatus:
    """Comparison status for a generated file."""

    file: GeneratedFile
    in_sync: bool
    diff: str | None = None

    @property
    def path(self) -> Path:
        return self.file.path


@dataclass(frozen=True)
class PropagationResult:
    """Result of executing the schema propagation pipeline."""

    statuses: tuple[FileStatus, ...]
    report: str
    mode: str

    @property
    def has_drift(self) -> bool:
        return any(not status.in_sync for status in self.statuses)


def _describe_python_type(tp: Any) -> str:
    """Return a stable string representation for ``tp``."""

    origin = get_origin(tp)

    if origin in {list, List}:  # type: ignore[arg-type]
        args = get_args(tp)
        inner = _describe_python_type(args[0]) if args else "Any"
        return f"list[{inner}]"
    if origin in {tuple, Tuple}:  # type: ignore[arg-type]
        args = get_args(tp)
        if args and args[-1] is Ellipsis:
            return f"tuple[{_describe_python_type(args[0])}, ...]"
        inner = ", ".join(_describe_python_type(arg) for arg in args)
        return f"tuple[{inner}]" if inner else "tuple"
    if origin in {dict, Dict, Mapping}:  # type: ignore[arg-type]
        args = get_args(tp)
        if len(args) == 2:
            key_repr = _describe_python_type(args[0])
            value_repr = _describe_python_type(args[1])
        else:
            key_repr = value_repr = "Any"
        return f"dict[{key_repr}, {value_repr}]"
    if origin in {set, Set, frozenset, FrozenSet}:  # type: ignore[arg-type]
        args = get_args(tp)
        inner = _describe_python_type(args[0]) if args else "Any"
        return f"set[{inner}]"
    if origin in {Union, types.UnionType}:
        args = get_args(tp)
        return " | ".join(_describe_python_type(arg) for arg in args)
    if origin is not None:
        args = get_args(tp)
        origin_name = getattr(origin, "__qualname__", repr(origin))
        module = getattr(origin, "__module__", "typing")
        prefix = "" if module in {"typing", "builtins"} else f"{module}."
        if args:
            args_repr = ", ".join(_describe_python_type(arg) for arg in args)
            return f"{prefix}{origin_name}[{args_repr}]"
        return f"{prefix}{origin_name}"

    if tp is Any:
        return "Any"
    if tp is type(None):
        return "None"
    module = getattr(tp, "__module__", "typing")
    name = getattr(tp, "__qualname__", repr(tp))
    if module in {"builtins", "typing"}:
        return name
    return f"{module}.{name}"


def _collect_field_descriptors() -> list[FieldDescriptor]:
    descriptors: list[FieldDescriptor] = []
    list_fields = set(schema.RECRUITING_WIZARD_LIST_FIELDS)
    types_map: Mapping[str, Any] = schema.RECRUITING_WIZARD_FIELD_TYPES
    for path in sorted(schema.RECRUITING_WIZARD_FIELDS):
        tp = types_map[path]
        descriptors.append(
            FieldDescriptor(
                path=path,
                python_type=_describe_python_type(tp),
                is_collection=path in list_fields,
            )
        )
    return descriptors


def _render_components_module(fields: Sequence[FieldDescriptor]) -> str:
    header = (
        '"""Auto-generated RecruitingWizard schema metadata.\n\n'
        "This file is generated by ``scripts/propagate_schema.py``.\n"
        'Do not edit manually.\n"""'
    )
    lines = [
        header,
        "# CS_SCHEMA_PROPAGATE | PIPE_PROP",
        "from __future__ import annotations",
        "",
        "from dataclasses import dataclass",
        "from typing import Final, Literal",
        "",
        "",
        "@dataclass(frozen=True, slots=True)",
        "class WizardFieldInfo:",
        '    """Metadata for a canonical RecruitingWizard field."""',
        "",
        "    path: str",
        "    python_type: str",
        "    is_collection: bool",
        "",
        "",
        "WIZARD_FIELDS: Final[tuple[WizardFieldInfo, ...]] = (",
    ]
    for field in fields:
        lines.append(
            '    WizardFieldInfo(path="{path}", python_type="{type}", is_collection={collection}),'.format(
                path=field.path,
                type=field.python_type,
                collection=str(field.is_collection),
            )
        )
    lines.append(")")
    lines.append("")
    lines.append("WizardField = Literal[")
    for field in fields:
        lines.append(f'    "{field.path}",')
    lines.append("]")
    lines.append("")
    lines.append("WIZARD_FIELD_PATHS: Final[tuple[WizardField, ...]] = (")
    for field in fields:
        lines.append(f'    "{field.path}",')
    lines.append(")")
    lines.append("")
    lines.append("WIZARD_LIST_FIELDS: Final[tuple[WizardField, ...]] = (")
    for field in fields:
        if field.is_collection:
            lines.append(f'    "{field.path}",')
    lines.append(")")
    lines.append("")
    lines.append("WIZARD_FIELD_TYPES: Final[dict[WizardField, str]] = {")
    for field in fields:
        lines.append(f'    "{field.path}": "{field.python_type}",')
    lines.append("}")
    lines.append("")
    lines.append(
        '__all__ = ["WizardFieldInfo", "WizardField", "WIZARD_FIELDS", "WIZARD_FIELD_PATHS", "WIZARD_FIELD_TYPES", "WIZARD_LIST_FIELDS"]'
    )
    lines.append("")
    return "\n".join(lines) + "\n"


def _render_exports_module(fields: Sequence[FieldDescriptor]) -> str:
    header = (
        '"""Auto-generated RecruitingWizard export helpers.\n\n'
        "This file is generated by ``scripts/propagate_schema.py``.\n"
        'Do not edit manually.\n"""'
    )
    lines = [
        header,
        "# CS_SCHEMA_PROPAGATE | PIPE_PROP",
        "from __future__ import annotations",
        "",
        "from dataclasses import dataclass",
        "from typing import Final, Iterable, Mapping",
        "",
        "from core.schema import RecruitingWizard",
        "",
        "from .models import RecruitingWizardExport",
        "",
        "",
        "@dataclass(frozen=True, slots=True)",
        "class WizardExportField:",
        '    """Metadata for a canonical RecruitingWizard export field."""',
        "",
        "    path: str",
        "    python_type: str",
        "    is_collection: bool",
        "",
        "",
        "WIZARD_EXPORT_FIELDS: Final[tuple[WizardExportField, ...]] = (",
    ]
    for field in fields:
        lines.append(
            '    WizardExportField(path="{path}", python_type="{type}", is_collection={collection}),'.format(
                path=field.path,
                type=field.python_type,
                collection=str(field.is_collection),
            )
        )
    lines.append(")")
    lines.append("")
    lines.append("WIZARD_EXPORT_FIELD_TYPES: Final[dict[str, str]] = {")
    for field in fields:
        lines.append(f'    "{field.path}": "{field.python_type}",')
    lines.append("}")
    lines.append("")
    lines.append("WIZARD_EXPORT_LIST_FIELDS: Final[tuple[str, ...]] = (")
    for field in fields:
        if field.is_collection:
            lines.append(f'    "{field.path}",')
    lines.append(")")
    lines.append("")
    lines.extend(
        [
            "def ensure_export_payload(",
            "    payload: Mapping[str, object] | RecruitingWizard",
            ") -> dict[str, object]:",
            '    """Validate ``payload`` against the RecruitingWizard schema and return a JSON payload."""',
            "",
            "    export = RecruitingWizardExport.from_payload(payload)",
            "    return export.to_dict()",
            "",
            "",
            "def iter_export_fields() -> Iterable[WizardExportField]:",
            '    """Yield the canonical export field descriptors."""',
            "",
            "    return WIZARD_EXPORT_FIELDS",
            "",
            "",
            "__all__ = [",
            '    "WizardExportField",',
            '    "WIZARD_EXPORT_FIELDS",',
            '    "WIZARD_EXPORT_FIELD_TYPES",',
            '    "WIZARD_EXPORT_LIST_FIELDS",',
            '    "ensure_export_payload",',
            '    "iter_export_fields",',
            "]",
            "",
        ]
    )
    return "\n".join(lines) + "\n"


def generate_files() -> list[GeneratedFile]:
    """Return the set of generated files for the propagation pipeline."""

    fields = _collect_field_descriptors()
    components_path = Path("components") / "wizard_schema_types.py"
    exports_path = Path("exports") / "transform.py"
    return [
        GeneratedFile(path=components_path, content=_render_components_module(fields)),
        GeneratedFile(path=exports_path, content=_render_exports_module(fields)),
    ]


def run_propagation(root: Path, *, apply: bool, mode: str) -> PropagationResult:
    """Execute the propagation process for ``root``."""

    statuses: list[FileStatus] = []
    for generated in generate_files():
        target = root / generated.path
        existing = target.read_text(encoding="utf-8") if target.exists() else ""
        if existing != generated.content:
            diff = "\n".join(
                unified_diff(
                    existing.splitlines(),
                    generated.content.splitlines(),
                    fromfile=str(generated.path),
                    tofile=str(generated.path),
                )
            )
            statuses.append(FileStatus(file=generated, in_sync=False, diff=diff))
            if apply:
                target.parent.mkdir(parents=True, exist_ok=True)
                target.write_text(generated.content, encoding="utf-8")
        else:
            statuses.append(FileStatus(file=generated, in_sync=True, diff=None))
    report = build_report(statuses, mode=mode)
    return PropagationResult(statuses=tuple(statuses), report=report, mode=mode)


def build_report(statuses: Sequence[FileStatus], mode: str) -> str:
    """Return a markdown report for ``statuses``."""

    lines = ["# Schema Propagation Report", "", f"* Mode: {mode}", ""]
    lines.extend(["| File | Status |", "| --- | --- |"])
    for status in statuses:
        symbol = "✅" if status.in_sync else "❌"
        message = "in sync" if status.in_sync else "drift detected"
        lines.append(f"| `{status.path}` | {symbol} {message} |")
    drift_sections = [status for status in statuses if not status.in_sync and status.diff]
    if drift_sections:
        lines.append("")
        lines.append("## Diffs")
        for status in drift_sections:
            lines.append("")
            lines.append(f"### `{status.path}`")
            lines.append("\n````diff")
            lines.append(status.diff)
            lines.append("````")
    else:
        lines.append("")
        lines.append("No drift detected. ✨")
    lines.append("")
    return "\n".join(lines)


def write_report(root: Path, report: str) -> Path:
    """Persist the markdown report to the artifacts directory."""

    artifacts_dir = root / "artifacts"
    artifacts_dir.mkdir(parents=True, exist_ok=True)
    report_path = artifacts_dir / "schema_report.md"
    report_path.write_text(report, encoding="utf-8")
    return report_path


__all__ = [
    "FieldDescriptor",
    "GeneratedFile",
    "FileStatus",
    "PropagationResult",
    "build_report",
    "generate_files",
    "run_propagation",
    "write_report",
]
