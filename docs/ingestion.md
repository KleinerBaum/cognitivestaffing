# Ingestion Notes / Hinweise zur Datenaufnahme

## Redirect handling / Weiterleitungs-Handling

**EN:** The `_fetch_url` helper in `ingest/extractors.py` follows up to **15** consecutive redirects before aborting. This mirrors the safeguards inside `requests` while providing an explicit cap for deployments that expose redirects via `raise_for_status`. Once the limit is exceeded the fetch stops and raises a `ValueError`, making redirect loops visible during monitoring.

**DE:** Der Helper `_fetch_url` in `ingest/extractors.py` folgt maximal **15** Weiterleitungen, bevor der Vorgang abgebrochen wird. Damit spiegeln wir die Schutzmechanismen von `requests` und setzen zugleich ein explizites Limit für Umgebungen, die Weiterleitungen über `raise_for_status` melden. Wird die Grenze überschritten, stoppt der Abruf und wirft einen `ValueError`, sodass Redirect-Schleifen in der Überwachung auffallen.

## Required contact email and city / Pflichtfelder für Kontakt und Stadt

**EN:** Both `company.contact_email` and `location.primary_city` are treated as required fields because exports, follow-up mailers, and salary benchmarks depend on them: without a monitored inbox we cannot route wizard-generated drafts for approval, and without the main city we cannot price the role, populate commute hints, or pre-fill HQ suggestions. The rule-based extractor in `core/rules.py` dedicates matchers (`EMAIL_FIELD` / `CITY_FIELD`) to capture these values early, and the ingestion-normalisation layer keeps missing data visible by converting unknown values to blank placeholders. `models/need_analysis.Company` and `models/need_analysis.Location` trim whitespace and intentionally return `""` for empty submissions, while `state/ensure_state._fix_contact_email_field` backfills an empty string whenever validation reports an invalid contact address. That convention flows through `openai_utils/extraction.py` so downstream heuristics know the field exists but still needs user input.

Whenever the extractor or heuristics leave the placeholders in place, the follow-up system automatically intervenes. The critical-field list in `critical_fields.json` / `question_logic.py` ensures both paths remain in `CRITICAL_FIELDS`, and `wizard/flow._missing_fields_for_section()` calls `_ensure_targeted_followup()` to inject bilingual prompts that reference the contact and city requirements. Those inline cards continue to re-ask until `followup_has_response()` (from `wizard.followups`) confirms a non-empty answer.

Finally, `wizard/flow._step_company()` blocks navigation while either placeholder is present. The Company step uses `persist_contact_email()` / `persist_primary_city()` validators to surface inline errors and appends the `REQUIRED_SUFFIX` when `_missing_fields_for_section(1)` reports that `company.contact_email` or `location.primary_city` is still empty. Because the same section gating is also used by the navigation controls, the wizard refuses to advance to later steps until both values contain real content. If we ever relax or extend this requirement, the touch points to update are `core/rules.py` (rule extraction and metadata locking), `question_logic.py` + `critical_fields.json` (critical follow-up registration), and the gating logic in `wizard/flow.py` (validators, required suffixes, and the section-level navigation checks).

**DE:** Sowohl `company.contact_email` als auch `location.primary_city` gelten als Pflichtfelder, weil Exporte, Follow-up-Mails und Gehaltsbenchmarks davon abhängen: Ohne überwachte Inbox können wir keine automatisch erzeugten Entwürfe zur Freigabe verschicken, und ohne Hauptstandort fehlen Preisindikationen, Pendelhinweise und HQ-Vorschläge. Der regelbasierte Extractor in `core/rules.py` besitzt eigene Matcher (`EMAIL_FIELD` / `CITY_FIELD`), um diese Werte früh einzusammeln, und die Normalisierungsschicht hält fehlende Angaben sichtbar, indem sie unbekannte Werte in leere Platzhalter verwandelt. `models/need_analysis.Company` und `models/need_analysis.Location` schneiden Eingaben zurecht und geben bei Leerfeldern bewusst `""` zurück, während `state/ensure_state._fix_contact_email_field` eine leere Zeichenkette nachträgt, sobald die Validierung eine ungültige Kontaktadresse meldet. Dieses Muster setzt sich in `openai_utils/extraction.py` fort, damit die Heuristiken erkennen, dass das Feld existiert, aber noch Eingaben braucht.

**EN:** `company.name` is no longer mandatory at extraction time. The Responses schema accepts a missing name and the wizard enqueues a bilingual follow-up card for it; once the user answers, `_apply_followup_updates` syncs the value back into the NeedAnalysis profile without re-running validation for the entire company block.

**DE:** `company.name` ist zur Extraktionszeit nicht mehr verpflichtend. Das Responses-Schema akzeptiert einen fehlenden Namen und der Wizard stellt automatisch eine zweisprachige Follow-up-Karte; nach der Antwort schreibt `_apply_followup_updates` den Wert ins NeedAnalysis-Profil zurück, ohne den kompletten Company-Block neu zu validieren.

Bleiben die Platzhalter nach Extraktion/Heuristiken bestehen, greift automatisch das Follow-up-System. Die Critical-Field-Liste in `critical_fields.json` bzw. `question_logic.py` stellt sicher, dass beide Felder in `CRITICAL_FIELDS` bleiben, und `wizard/flow._missing_fields_for_section()` ruft `_ensure_targeted_followup()` auf, um zweisprachige Nachfragen zu rendern, die auf die Kontakt- und Stadtpflicht hinweisen. Diese Karten fragen so lange nach, bis `followup_has_response()` (`wizard.followups`) eine echte Antwort erkennt.

Zum Schluss blockiert `wizard/flow._step_company()` die Navigation, solange einer der Platzhalter gesetzt ist. Der Unternehmensschritt nutzt `persist_contact_email()` / `persist_primary_city()` zur Inline-Validierung und ergänzt `REQUIRED_SUFFIX`, sobald `_missing_fields_for_section(1)` meldet, dass `company.contact_email` oder `location.primary_city` leer ist. Weil dieselbe Abschnittsprüfung auch die Navigation steuert, lässt der Wizard erst weiterklicken, wenn beide Felder echte Inhalte besitzen. Sollten wir diese Anforderung lockern oder erweitern, müssen `core/rules.py` (Regel-Extraktion & Locking), `question_logic.py` + `critical_fields.json` (Critical-Follow-ups) sowie die Blockierungslogik in `wizard/flow.py` (Validatoren, Pflicht-Hinweise, Abschnitts-Checks) aktualisiert werden.
